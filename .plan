durable, resumable, asynchronous file transfer
==============================================

session
    - tx/rx multiple files
    - open net endpoints
    - own buf pool
    - own queue
    - own exec

    auto s = txsession(config)
        - create net eps
    s.start(...)
        - take file list, path, generator
        - wrap senders around net eps
        - add senders to exec
        - for each file, open, create reader
            - add reader(s) to exec
            - get next reader when current completes or current file size < thresh

    --
    auto s = rxsession(config)
        - create net eps
    [awaitXferReq]
    s.start(...)
        - take file map arg
        - wrap receivers around net eps
        - add receivers to exec
        - for reach file, open, add to vec
        - wrap writer(s) around vec
        - add writer to exec

    s.runonce

--
- rx to fill bufs
- header inline w/data, padded
- tail writes padded by reader/sender
    - rx can issue mixed inner/tail writes w/o leaking data from other files rx'd into megabuf
- megabuf from pool
    - rx fills
    - rx walks through, creating & enqueuing subbufs
    - subbufs are megabuf markers + shared ptr to megabuf
    - all subbufs freed, megabuf returns to pool
- rx to open files on demand instead of holding all descs open for duration of xfer
- rx to track completion for each file, truncate at end & close

- spdk/dpdk

- usability
    - [ ] multiple rx (persistent receiver)
    - [ ] bind to i/f
    - [ ] bind to ANY
    - [ ] stats
    - [ ] progress
        - session?
    - [ ] tui
    - [ ] configurable buf size, r/w/tx/rx thd counts
